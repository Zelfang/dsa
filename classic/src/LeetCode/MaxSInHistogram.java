package LeetCode;

import java.util.Arrays;
import java.util.Stack;

/**
 * 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
 * 求在该柱状图中，能够勾勒出来的矩形的最大面积。
 * <p>
 * 示例：每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。
 * 所能勾勒出的最大矩形面积，其面积为 10 个单位。
 * <p>
 * 示例:
 * 输入: [2,1,5,6,2,3]
 * 输出: 10
 */
public class MaxSInHistogram {
    public static void main(String[] args) {
        System.out.println(new MaxSInHistogram().largestRectangleArea(new int[]{2, 4, 5, 3, 2}));
    }

    /**
     * 思路：单调栈
     * 维护一个单调递增栈，因为单调递增栈的出栈顺序总是栈中较大的元素先出栈
     * 如果一个较大元素累加到了最终最大矩形面积的计算，那么可能分为两种情况：
     * 1 该元素的全部都参与了计算，说明最终形成矩形的元素长度都大于等于该元素
     *   根据单调递增栈的性质，此前出栈的元素值都不小于当前元素，而下一个要入栈的元素是严格小于当前元素的
     *   那么我们就可以使用【当前出栈元素的值】乘【当前等待入栈的元素与栈顶元素在原数组中中间包含了几个元素】去竞争最终的矩形最大值
     *   这里需要理解的是矩形宽和高的来源：
     *   1 高度很简单因为我们假设当前弹栈元素全部参与计算，如果最终矩形高度超过该值显然当前元素就无法参与计算，如果小于当前元素又与假设违背
     *   2 宽度是根据单调递增栈的性质得出的，该元素能弹栈说明下一个要入栈的元素比该元素小，那么下一个入栈的元素及其右边的元素就不能参与计算
     *      而栈中元素又是单调递增的，所以栈顶元素只能小于等于出栈元素
     *          如果小于那么宽度只能是从该元素起到等待入栈的元素之前一个元素的个数
     *          如果等于那么栈顶元素也必定会弹栈进行相同的运算，那么包含该元素的全部的最大矩形面积会在下一次弹栈时得到
     * 2 如果该元素的部分参与到了计算，那么最终最大矩形面积的高度一定（也可能最大值不在包含该元素的递增序列中）累加了其参与的部分
     *   这么说的原因可以参考情况1中计算宽度的因子，下表变换时中间涵盖的几个元素参与计算的部分多数情况下只是其部分高度
     *
     * 最后要注意的是，当所有元素遍历结束后，栈中可能还有剩余元素，也需要弹栈计算（这些值一般属于高度较小但宽度较大的矩形）
     * 为了统一运算，只需要最后把0入栈即可使栈中的非零元素都弹栈
     */
    public int largestRectangleArea(int[] heights) {
        if (heights.length == 0)
            return 0;
        if (heights.length == 1)
            return heights[0];
        int max = 0;
//        将原数组复制到原数组长度＋1的新数组中，最后一位默认为0
        heights = Arrays.copyOf(heights, heights.length + 1);
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < heights.length; i++) {
            while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {
                int index = stack.pop();
//                这里需要注意，当弹栈的过程中所有元素都弹栈后，入栈元素直接乘其下标即为该元素高度在原子序列中参与计算的结果
//                即要入栈的元素比栈中所有元素都小，也即该元素在原数组中左边的所有元素都比他大
                max = Math.max(max, heights[index] * (stack.isEmpty() ? i : i - stack.peek() - 1));
            }
            stack.push(i);
        }
        return max;
    }
}
