package foundation;

public class Complexity {
	public static void main(String[] args) {
		/**
		 * 常数时间的操作：数组寻址，加减乘除，位运算（位运算的常数项系数小于加减乘除运算）
		 * 整型/2=右移1位
		 * 时间复杂度：数据情况最差情况下忽略低阶项和高阶项的系数O(f(N)),读作big O f(N)
		 * 先比较指标，再比较常数项
		 * 样本量未能确定时，多个参数无法对指标进行比较
		 */
		System.out.println(8/2);
		System.out.println(8>>1);
		/**
		 * 对数器：
		 * 1.有一个你想要测试的方法a
		 * 2.实现一个绝对正确但复杂度不好的方法b
		 * 3.实现一个随机样本产生器
		 * 4.把方法a和方法b比对很多次来验证方法a是否正确
		 * 5.如果有一个样本使得比对出错，打印样本分析是哪个方法出错
		 * 6.当样本数量很多时比对测试依然正确，可以确定方法a已经正确
		 */
		/**
		 * 递归：系统栈
		 * 任何递归行为都可以改写成非递归
		 * 估计递归程序复杂度的通式：
		 * T(N)=aT(N/b)+O(n^d)
		 * 其中，N/b为子过程的样本量，a为子过程发生的次数，n^d为剩下部分的时间复杂度
		 * master公示适用范围：子过程划分样本量必须平均
		 * 情况1：log(b,a)>d	--->	时间复杂度O(N^log(b,a))
		 * 情况2：log(b,a)=d	--->	时间复杂度O(N^d*log(N))
		 * 情况3：log(b,a)<d	--->	时间复杂度O(N^d)
		 */
		/**
		 * 排序的相对稳定性：所有的相同值，不会因为排序算法被打乱
		 * 意义：原始信息的排序结果不被抹去
		 * 冒泡排序：可以设计成稳定的，相同值相遇时不进行交换
		 * 插入排序：可以设计成稳定的，遇到相同值在其后面插入
		 * 选择排序：不稳定，其交换过程是跨元素的
		 * 归并排序：稳定，在合并的过程中先拷贝左边的在拷贝另一边的
		 * 快速排序：不稳定，划分的过程中跨元素交换
		 * 堆排序：不稳定
		 */
		/**
		 * 工程上的综合排序：
		 * 数组长度较长时：
		 * 基础类型--->快排（基础类型不追求稳定性）
		 * 自定义类型--->归并排序（自定义类型追求稳定性，归并的过程中样本量一旦小于60，直接插排）
		 * 数组长度较短时：
		 * 不考虑类型，直接用插入排序（插入排序的常数项很低，小样本情况适用，数组长度小于60）
		 */
	}
}
