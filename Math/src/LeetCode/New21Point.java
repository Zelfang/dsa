package LeetCode;

/**
 * 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
 * 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。
 * 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。
 * 每次抽取都是独立的，其结果具有相同的概率。
 * 当爱丽丝获得不少于 K 分时，她就停止抽取数字。
 * 爱丽丝的分数不超过 N 的概率是多少？
 * <p>
 * 示例 1：
 * 输入：N = 10, K = 1, W = 10
 * 输出：1.00000
 * 说明：爱丽丝得到一张卡，然后停止。
 * 示例 2：
 * 输入：N = 6, K = 1, W = 10
 * 输出：0.60000
 * 说明：爱丽丝得到一张卡，然后停止。
 * 在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。
 * 示例 3：
 * 输入：N = 21, K = 17, W = 10
 * 输出：0.73278
 * <p>
 * 提示：
 * 0 <= K <= N <= 10000
 * 1 <= W <= 10000
 * 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。
 * 此问题的判断限制时间已经减少。
 */
public class New21Point {
    public static void main(String[] args) {
        System.out.println(new New21Point().new21Game1(21, 17, 10));
    }

    /**
     * 思路1：动态规划
     * 我们将某一次累加后的点数和作为子状态
     * 由于随机抽取的范围是从1开始的，所以在整个累加的过程中，从0到所能取到的最大点数之间的所有状态都有可能取到
     * 因此dp数组的长度为所能取到的最大点数和+1（初始0状态），最终从后往前递推出初始状态的概率即可
     * 【时间复杂度，O((K+W)*W)超时】
     */
    public double new21Game(int N, int K, int W) {
//        所能取到的最大点数为K-1+W，因此数组长度为K+W
        double[] dp = new double[K + W];
//        dp数组的初始值为K-1之后的状态（因为K-1为可以再进行下一次抽取的最大点数，下一次抽取后累加和一定大于等于K，无法再抽取）
        for (int i = K; i < dp.length; i++)
//            对于最后一次抽取的累加点数，直接和N进行比较即可得出当前状态小于等于N的概率（因为已经产生结果，所以概率非0即1）
            if (i > N)
                dp[i] = 0;
            else
                dp[i] = 1;
//        转移方程：dp[i] = 1/W *(dp[i+1]+dp[i+2]+......+dp[i+W])
//        可以理解成在点数和为i的状态下，我们有1/W的等概率抽取累加结果为i+1、i+2、……、i+W
//        而之后这些状态下取得最终结果的概率已知，因此可以通过加权平均法得到i的dp值，即结果概率
        for (int i = K - 1; i >= 0; i--) {
            double sum = 0;
            for (int j = i + 1; j <= i + W; j++)
                sum += dp[j];
            dp[i] = sum / W;
        }
//        最终我们想得到的是初始状态下的结果概率
        return dp[0];
    }

    /**
     * 思路2：优化后的dp
     * 前面我们发现在计算概率累加和时，每一次计算新的dp状态时所要累加的范围只是移动了一个元素
     * 因此可以通过O(1)的时间完成累加的过程
     */
    public double new21Game1(int N, int K, int W) {
        double[] dp = new double[K + W];
        double sum = 0;
        for (int i = K; i < dp.length; i++) {
            if (i > N)
                dp[i] = 0;
            else
                dp[i] = 1;
//            初始值判定时直接累加第一次的dp和
            sum += dp[i];
        }
        for (int i = K - 1; i >= 0; i--) {
            dp[i] = sum / W;
//            每次计算新的dp值时将累加范围向前移动一格
            sum += dp[i];
            sum -= dp[i + W];
        }
        return dp[0];
    }
}
